Bellman-Ford Algorithm:
procedure BellmanFord(Graph, source):
    // Initialize distances and predecessors
    for each vertex v in Graph:
        distance[v] := INFINITY
        predecessor[v] := NULL
    distance[source] := 0
    
    // Relax edges repeatedly
    for i from 1 to |V| - 1:
        for each edge (u, v) in Edges:
            if distance[u] + weight(u, v) < distance[v]:
                distance[v] := distance[u] + weight(u, v)
                predecessor[v] := u
                
    // Check for negative cycles
    for each edge (u, v) in Edges:
        if distance[u] + weight(u, v) < distance[v]:
            // Negative cycle found, handle accordingly
            return "Negative cycle detected"
    
    return distance, predecessor
Dijkstra's Algorithm:
procedure Dijkstra(Graph, source):
    // Initialize distances and predecessors
    for each vertex v in Graph:
        distance[v] := INFINITY
        predecessor[v] := NULL
    distance[source] := 0
    
    // Priority queue to store vertices and their distances
    priorityQueue := createPriorityQueue()
    enqueue(priorityQueue, source, distance[source])
    
    while priorityQueue is not empty:
        current := dequeue(priorityQueue)
        
        for each neighbor in neighbors(current):
            alt := distance[current] + weight(current, neighbor)
            if alt < distance[neighbor]:
                distance[neighbor] := alt
                predecessor[neighbor] := current
                enqueue(priorityQueue, neighbor, distance[neighbor])
    
    return distance, predecessor
Prim's Algorithm:
procedure Prim(Graph):
    // Initialize set of vertices in the minimum spanning tree
    MSTSet := emptySet
    
    // Priority queue to store edges and their weights
    priorityQueue := createPriorityQueue()
    
    // Choose any arbitrary vertex as the starting point
    startVertex := anyVertex(Graph)
    MSTSet.add(startVertex)
    
    // Add edges from the start vertex to the priority queue
    for each edge (startVertex, neighbor) in neighbors(startVertex):
        enqueue(priorityQueue, (startVertex, neighbor), weight(startVertex, neighbor))
    
    while MSTSet does not contain all vertices:
        edge := dequeue(priorityQueue)
        if edge is not in MSTSet:
            add edge to MSTSet
            for each neighbor in neighbors(edge.end):
                if neighbor is not in MSTSet:
                    enqueue(priorityQueue, (edge.end, neighbor), weight(edge.end, neighbor))
    
    return MSTSet
Kruskal's Algorithm:
procedure Kruskal(Graph):
    // Initialize set of disjoint sets for each vertex
    sets := makeSet(Graph.vertices)
    
    // Priority queue to store edges and their weights
    priorityQueue := createPriorityQueue()
    
    // Add all edges to the priority queue
    for each edge in Graph.edges:
        enqueue(priorityQueue, edge, weight(edge))
    
    // Initialize the minimum spanning tree
    MST := emptySet
    
    while MST does not form a spanning tree and priorityQueue is not empty:
        edge := dequeue(priorityQueue)
        if findSet(edge.start) != findSet(edge.end):
            MST.add(edge)
            unionSets(findSet(edge.start), findSet(edge.end))
    
    return MST